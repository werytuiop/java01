	
	* 절차 지향 언어와 객체 지향 언어
	
		- 절차 지향 언어 : 작업순서(알고리즘)를 표현 (함수들의 집합으로 프로그래밍) (ex: C언어)
		- 객체 지향 언어 : 미리 사용할 목적으로 설계도(클래스)를 완성하고 그 객체를 이용해서 프로그래밍 (ex: JAVA, C++)
		
	
	* 객체 지향 언어의 목적
	
		- 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
		- 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
		- 소프트웨어의 재사용과 부분 수정 빠르고 생산성 향상 
		
		
		① 객체 모델링 -> DB 모델링 -> ERD
		② 클래스를 설계 (Class Diagram)
		③ 프로그래밍

		
	1. 객체 (Object, Instance)
	
		## 클래스를 통해 만들어진 현실 사물체, 현실 세계의 모든 것을 나타냄
		- "세상 모든 것이 객체다."
		- 객체 멤버 : 속성(필드, 프로퍼티), 메소드(기능)
		- 인스턴스 : 클래스를 통해서 만들어진 것, 클래스의 인스턴스
		
			------ 인스턴스화(객체화) ------------
			클래스타입 객체참조변수 = new 생성자();
			String str = new String("asdf");
			str.멤버; // 이렇게 접근
			---------------------------------
				└ new : 객체 생성 연산자
				└ . : 객체 접근 연산자
				└ str : 객체의 주소
		
		
	2. 클래스 (Class)
	
		## 객체를 생성하기 위한 설계도(틀)
		- 사용자 정의 타입 ★★
		- 객체의 속성과 기능 선언

			------ 클래스 구성 -------
			접근제한자 class 클래스명 {
				접근제한자 필드;
				접근제한자 메소드;
			}
			----------------------

		== 클래스 명명 규칙 ==
	
			- 대문자로 시작
			- 한글을 사용하지 않음
			- 특수기호는 _, $ 이외에 사용할 수 없음
			- 공백을 허용하지 않음
			- 파스칼표기법
			
			
	* Class 멤버
		
		1) 필드
			= 멤버변수, 프로퍼티, 속성
			- 하나의 값을 setting / getting
				----------------		
				접근제한자 타입 필드명;
				----------------
			
		2) 메소드
			- 함수, 기능
			- 처리, 구현, 호출
			- return문을 만나면 종료
			- 구현부가 있으면 구현하고 return값을 반환하고 종료
			- 호출(call)할 때마다 새로 생성됨
			- 지역변수는 메소드 호출 시 생성되고 종료시 사라짐 (가비지 컬렉션)
				------------------------------------		
				접근제한자 반환타입 메소드명 (입력인자) {
						return 반환값; // 반환값이 없으면 생략
				}
				------------------------------------
				
			== 메소드 유형 ==
			
				┌ void : return값이 없다 (생략가능)
				┌ 반환타입 있으면 반드시 return 값이 있어야함
				
				------ 반환 타입 X 입력값 X -------------
				public void 메소드명() {
					// 구현부;
					// return;
				}
				-----------------------------------
				
				------ 반환 타입 X 입력값 O -------------
				public void method(int num1, int num2) {
					int sum = num1 + num2; // 메소드 안에 선언된 변수(지역변수)
					// return;
				}
				------------------------------------
			
				------ 반환 타입 O 입력값 X --------------
				public int method() {
					return 반환값;
				}
				------------------------------------
			
				------ 반환 타입 O 입력값 O --------------
				public int method (int num1, int num2) {
					int sum = num1 + num2;
					return 반환값;
				}
				------------------------------------
		
		
	* 인스턴스와 클래스
	
		┌ 필드 : 인스턴스, 클래스
		└ 메소드 : 인스턴스, 클래스
		
		1) 인스턴스 멤버 (instance 멤버)
			----------------------------
			Class01 c1 = new Class01();
			c1.userId = "";
			----------------------------
				객체별로 별도 존재
				객체 생성시에 멤버생성됨
				공유되지않음
				객체가 사라지면 멤버도 사라짐
				객체를 생성한 후에 사용 가능 (인스턴스화)
				객체가 생성되면 생성되고 객체가 소멸되면 종료
				인스턴스 멤버는 new 키워드를 통해 힙 영역에 존재
			
		2) 클래스 멤버 (static 멤버)
			---------------------
			Class01.userId = "";
			---------------------
				클래스 당 하나만 생성
				클래스 멤버는 공유 가능
				객체들에 의해 공유됨 (클래스이름.클래스멤버)
				프로그램이 종료될 때 사라짐
				클래스가 생성되면 생성되고 클래스가 소멸되면 종료
				DB Connect: DB연동클래스 등
			
			
			== non-static / static ==
			
			│			│		non-static			│		static
			│────────┼──────────────────────────────────────────────────
			│			│class Sample {			│class Sample {
			│	선언		│	int n;					│	static int m;
			│			│	void g() {} }			│	static void g() {} }
			│────────┼──────────────────────────────────────────────────
			│			│								│멤버는 클래스당 하나 생성
			│	공간적	│멤버는 객체마다 별도로 존재		│멤버는 객체 내부가 아닌 별도의 공간에 생성
			│	특성		│인스턴스 멤버라고 부름			│클래스 멤버라고 부름
			│────────┼──────────────────────────────────────────────────
			│			│								│클래스 로딩시에 멤버 생성
			│	시간적	│객체 생성 시 멤버 생성				│객체가 생기기전에 이미 생성
			│	특성		│객체 생성 후 멤버 사용 가능			│객체가 생기기전에도 사용 가능
			│			│객체 사라지면 멤버도 사라짐		│객체가 사라져도 멤버는 사라지지 않음
			│			│								│멤버는 프로그램이 종료될 때 사라짐
			│────────┼───────────────────────────────────────────────────
			│	공유		│공유되지 않음					│동일한 클래스의 모든 객체들에 의해 공유됨
			│			│(멤버는 객체 내에 각각의 공간 유지)	│


			
	* 참조타입 (reference type)
		- 생성된 객체의 주소값을 대입
		- 객체.멤버 로 접근
			
	* 캡슐화
		- 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
		- 객체의 가장 본질적인 특징
		- 외부의 접근으로부터 객체 보호
		
	* 자바의 캡슐화
		- 클래스 : 객체 모양을 선언한 틀 (캡슐화 할 틀)
		- 객체 : 생성된 실체 (인스턴스)
		- 클래스 내에 메소드와 필드 구현
		
		
	* 접근 제한자 (접근지정자, Modify)
	
		- 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
		- 객체지향언어의 캡슐화 정책은 멤버를 보호하는 것 (접근지정은 캡슐화에 묶인 보호를 일부 해제할 목적)
		
		1) public
			- 패키지에 관계없이 모든 클래스에서 접근 가능 (공용)
		2) protected
			- 같은 패키지 내에서 접근 가능
			- 다른 패키지의 자손 클래스에서 접근 가능
		3) default (생략)
			= package-private
			- 같은 패키지 내에서만 접근 가능
		4) private
			- 같은 클래스 내에서만 접근 가능
			- 보통 내부 클래스 생성시 사용
			- 같은 패키지의 자손 클래스에서도 접근 불가
			- getter, setter로 접근

		(제어자)		같은 클래스	같은 패키지	자손 클래스	전체
		public		=======	=======	=======	===
		protected	=======	=======	=======
		default		=======	=======
		private		=======
		
		== 다른 패키지에서 class를 사용할 때 ==
		
			- import 패키지경로.클래스명; (패키지에 있는 해당 클래스만)
			- import 패키지경로.*; (패키지에 있는 모든 클래스)
			
			
	* final / static
	
		1) static
			
				- '고정된', 클래스 멤버를 선언할 때 객체 생성 없이 사용할 수 있음
				
	
		1) final
			
			- 한 번만 초기화 가능
			
			
	<접근가능 여부>
	static >>> static (O)
	instance >>> static (O)
	static >>> instance (X)
		-> static 메소드에서는 instance 멤버 X
		
		
	final : 마지막.최종적. 상수,메소드,클래스를 정의한 뒤 변경하지 못하게 할 때
	final 상수는 생성과 동시에 초기화 해야함. 변경 불가
	static : 정적. 클래스 멤버를 선언할 때
	
	this : 객체 자신
	this.멤버;
	this.필드;
	this.메소드();
	
	
		
	








		